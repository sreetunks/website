(() => {
  // <stdin>
  console.log("This site was generated by Hugo.");
  document.addEventListener("DOMContentLoaded", () => {
    const upvoteContainers = Array.from(document.querySelectorAll("[data-upvote]"));
    if (upvoteContainers.length) {
      const hasMoved = { value: false };
      const started = Date.now();
      const movementHandler = () => {
        hasMoved.value = true;
      };
      document.addEventListener("mousemove", movementHandler, { once: true });
      document.addEventListener("touchmove", movementHandler, { once: true });
      upvoteContainers.forEach((container) => {
        const slug = container.getAttribute("data-slug");
        const endpoint = container.getAttribute("data-endpoint");
        const infoEndpoint = container.getAttribute("data-info-endpoint");
        const upvotedTitle = container.getAttribute("data-upvoted-title") || "";
        const form = container.querySelector("form");
        const button = container.querySelector(".upvote-button");
        const countEl = container.querySelector(".upvote-count");
        if (!slug || !endpoint || !infoEndpoint || !form || !button || !countEl) {
          return;
        }
        const updateState = ({ upvote_count, upvoted }) => {
          if (typeof upvote_count === "number") {
            countEl.textContent = upvote_count.toString();
            button.classList.remove("upvote-button--cool", "upvote-button--warm", "upvote-button--hot");
            if (upvote_count >= 100) {
              button.classList.add("upvote-button--hot");
            } else if (upvote_count >= 10) {
              button.classList.add("upvote-button--warm");
            } else {
              button.classList.add("upvote-button--cool");
            }
          }
          if (upvoted) {
            button.disabled = true;
            button.classList.add("upvote-button--active");
            if (upvotedTitle) button.title = upvotedTitle;
          }
        };
        const readHidden = (name) => {
          const el = form.querySelector(`input[name="${name}"]`);
          return el && typeof el.value === "string" ? el.value : "";
        };
        const title = readHidden("title");
        const permalink = readHidden("permalink");
        const dateISO = readHidden("dateISO");
        const infoUrl = new URL(infoEndpoint, window.location.origin);
        infoUrl.searchParams.set("slug", slug);
        if (title) infoUrl.searchParams.set("title", title);
        if (permalink) infoUrl.searchParams.set("permalink", permalink);
        if (dateISO) infoUrl.searchParams.set("dateISO", dateISO);
        fetch(infoUrl.toString(), { credentials: "include" }).then((resp) => resp.ok ? resp.json() : null).then((data) => {
          if (!data) return;
          updateState(data);
        }).catch(() => {
        });
        form.addEventListener("submit", (e) => {
          e.preventDefault();
          if (button.disabled) return;
          if (!hasMoved.value || Date.now() - started < 2e3) return;
          fetch(endpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ slug, title, permalink, dateISO }),
            credentials: "include"
          }).then((resp) => resp.ok ? resp.json() : null).then((data) => {
            if (!data) return;
            updateState(data);
            if (typeof data.upvote_count === "number") {
              countEl.textContent = data.upvote_count.toString();
            } else {
              const current = parseInt(countEl.textContent || "0", 10) || 0;
              countEl.textContent = String(current + 1);
            }
          }).catch(() => {
          });
        });
      });
    }
    const navToggleBtn = document.querySelector("[data-nav-toggle]");
    const navEl = document.querySelector("[data-nav]");
    if (navToggleBtn && navEl) {
      navToggleBtn.addEventListener("click", () => {
        const open = navEl.classList.toggle("is-open");
        navToggleBtn.setAttribute("aria-expanded", open ? "true" : "false");
      });
    }
    const toc = document.querySelector(".toc-dropdown");
    if (toc) {
      toc.addEventListener("click", (e) => {
        const target = e.target;
        if (target && target.tagName === "A") {
          toc.open = false;
        }
      });
    }
    const searchInput = document.getElementById("archive-search");
    const groupsEl = document.getElementById("archive-groups");
    const resultsEl = document.getElementById("archive-results");
    if (searchInput && resultsEl) {
      let fuseInstance = null;
      let indexData = null;
      const indexUrl = searchInput.getAttribute("data-index-url") || "/index.json";
      const noResultsText = searchInput.getAttribute("data-no-results") || "No results";
      const fuseSrc = "https://cdn.jsdelivr.net/npm/fuse.js@7.0.0";
      const escapeHtml = (value) => String(value).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
      const collectMatchedLines = ({ item, matches }, query) => {
        const lines = /* @__PURE__ */ new Set();
        const safeQuery = String(query || "").trim().toLowerCase();
        const queryTerms = safeQuery.length ? safeQuery.split(/\s+/).filter(Boolean) : [];
        const normalizeSnippetLine = (line) => {
          let out = String(line || "").trim();
          if (!out) return "";
          if (out === "```") return "";
          out = out.replace(/^#{1,6}\s+/, "").replace(/^\s*([-*+]|\d+\.)\s+/, "").replace(/^>\s+/, "").replace(/!\[([^\]]*)\]\([^)]+\)/g, "$1").replace(/\[([^\]]+)\]\([^)]+\)/g, "$1").replace(/`([^`]+)`/g, "$1").trim();
          return out;
        };
        const content = typeof item.content === "string" ? item.content.replace(/\r\n/g, "\n") : "";
        const summary = typeof item.summary === "string" ? item.summary.replace(/\r\n/g, "\n") : "";
        const matchArr = Array.isArray(matches) ? matches : [];
        const contentMatches = matchArr.filter((m) => m && m.key === "content" && Array.isArray(m.indices));
        contentMatches.forEach((m) => {
          const value = typeof m.value === "string" ? m.value.replace(/\r\n/g, "\n") : content;
          if (!value) return;
          m.indices.forEach((pair) => {
            if (!Array.isArray(pair) || pair.length < 2) return;
            const startIndex = pair[0];
            const endIndex = pair[1];
            if (typeof startIndex !== "number" || typeof endIndex !== "number") return;
            const lineStartIdx = value.lastIndexOf("\n", startIndex);
            const lineStart = lineStartIdx === -1 ? 0 : lineStartIdx + 1;
            const lineEndIdx = value.indexOf("\n", endIndex + 1);
            const lineEnd = lineEndIdx === -1 ? value.length : lineEndIdx;
            const line = normalizeSnippetLine(value.slice(lineStart, lineEnd));
            if (line) lines.add(line);
          });
        });
        if (lines.size === 0 && content && queryTerms.length) {
          content.split(/\n+/).forEach((line) => {
            const trimmed = normalizeSnippetLine(line);
            if (!trimmed) return;
            const lower = trimmed.toLowerCase();
            if (queryTerms.every((term) => lower.includes(term))) {
              lines.add(trimmed);
            }
          });
        }
        if (lines.size === 0 && summary && queryTerms.length) {
          summary.split(/\n+/).forEach((line) => {
            const trimmed = normalizeSnippetLine(line);
            if (!trimmed) return;
            const lower = trimmed.toLowerCase();
            if (queryTerms.every((term) => lower.includes(term))) {
              lines.add(trimmed);
            }
          });
        }
        return Array.from(lines);
      };
      const renderResults = (items, query) => {
        if (!Array.isArray(items)) return;
        if (items.length === 0) {
          resultsEl.innerHTML = `<p class="text-[var(--color-muted)]">${escapeHtml(noResultsText)}</p>`;
          return;
        }
        const normalized = items.map((r) => ({
          item: r && r.item ? r.item : r,
          matches: r && Array.isArray(r.matches) ? r.matches : []
        })).filter((x) => x.item);
        const grouped = /* @__PURE__ */ new Map();
        normalized.forEach((r) => {
          const year = r.item.year || (typeof r.item.dateISO === "string" ? r.item.dateISO.slice(0, 4) : "");
          if (!grouped.has(year)) grouped.set(year, []);
          grouped.get(year).push(r);
        });
        const years = Array.from(grouped.keys()).filter(Boolean).sort((a, b) => (Number(b) || 0) - (Number(a) || 0));
        const groupHtml = years.map((year) => {
          const groupItems = grouped.get(year) || [];
          groupItems.sort((a, b) => String(b.item.dateISO || "").localeCompare(String(a.item.dateISO || "")));
          const itemsHtml = groupItems.map((r) => {
            const title = r.item.title || "";
            const dateShort = r.item.dateShort || r.item.date || "";
            const dateISO = r.item.dateISO || "";
            const link = r.item.permalink || "#";
            const matchedLines = collectMatchedLines(r, query);
            const snippetHtml = matchedLines.length ? `
              <div class="flex gap-4 mt-1">
                <span aria-hidden="true" class="text-sm text-[var(--color-muted)] font-mono shrink-0 opacity-0">${escapeHtml(dateShort)}</span>
                <div>
                  ${matchedLines.map((line) => `<p class="text-sm text-[var(--color-muted)] font-mono break-all">${escapeHtml(line)}</p>`).join("")}
                </div>
              </div>
            ` : "";
            return `
            <li>
              <div class="flex gap-4 items-baseline">
                <time class="text-sm text-[var(--color-muted)] font-mono shrink-0" datetime="${escapeHtml(dateISO)}">
                  ${escapeHtml(dateShort)}
                </time>
                <a href="${escapeHtml(link)}" class="hover:text-[var(--color-accent)] transition-colors truncate">
                  ${escapeHtml(title)}
                </a>
              </div>
              ${snippetHtml}
            </li>
          `;
          }).join("");
          return `
          <div class="mb-8">
            <h2 class="text-xl font-semibold mb-4 text-[var(--color-muted)]">${escapeHtml(year)}</h2>
            <ul class="space-y-2">
              ${itemsHtml}
            </ul>
          </div>
        `;
        }).join("");
        resultsEl.innerHTML = groupHtml;
      };
      const showGroups = () => {
        if (groupsEl) groupsEl.hidden = false;
        resultsEl.hidden = true;
      };
      const showResults = () => {
        if (groupsEl) groupsEl.hidden = true;
        resultsEl.hidden = false;
      };
      searchInput.setAttribute("role", "search");
      const loadScriptOnce = (src) => {
        const existing = document.querySelector(`script[src="${src}"]`);
        if (existing) {
          if (window.Fuse) return Promise.resolve();
          return new Promise((resolve, reject) => {
            existing.addEventListener("load", () => resolve(), { once: true });
            existing.addEventListener("error", () => reject(new Error(`Failed to load ${src}`)), { once: true });
          });
        }
        return new Promise((resolve, reject) => {
          const s = document.createElement("script");
          s.src = src;
          s.defer = true;
          s.onload = () => resolve();
          s.onerror = () => reject(new Error(`Failed to load ${src}`));
          document.head.appendChild(s);
        });
      };
      const loadFuseCtor = async () => {
        if (window.Fuse) return window.Fuse;
        try {
          await loadScriptOnce(fuseSrc);
        } catch (e) {
          return null;
        }
        return window.Fuse || null;
      };
      const initFuse = async () => {
        if (fuseInstance) return fuseInstance;
        if (!indexData) {
          try {
            const res = await fetch(indexUrl);
            if (!res.ok) return null;
            indexData = await res.json();
          } catch (e) {
            return null;
          }
        }
        if (!Array.isArray(indexData)) return null;
        const Fuse = await loadFuseCtor();
        if (!Fuse) return null;
        const options = {
          includeScore: true,
          includeMatches: true,
          findAllMatches: true,
          ignoreLocation: true,
          minMatchCharLength: 2,
          threshold: 0.3,
          keys: [
            { name: "title", weight: 2 },
            { name: "summary", weight: 1 },
            { name: "tags", weight: 0.5 },
            { name: "categories", weight: 0.5 },
            { name: "content", weight: 0.25 }
          ]
        };
        fuseInstance = new Fuse(indexData, options);
        return fuseInstance;
      };
      searchInput.addEventListener("focus", () => {
        void initFuse();
      }, { once: true });
      searchInput.addEventListener("input", async (ev) => {
        const q = (ev.target.value || "").trim();
        if (q.length === 0) {
          showGroups();
          return;
        }
        const fuse = await initFuse();
        if (!fuse) return;
        const results = fuse.search(q).slice(0, 50);
        renderResults(results, q);
        showResults();
      });
      if (!groupsEl) {
        resultsEl.hidden = true;
      }
    }
    (() => {
      const container = document.querySelector("main");
      if (!container) return;
      if (!container.querySelector("a[data-pswp-width], a.lightbox-image, img")) return;
      const photoswipeCss = "https://cdn.jsdelivr.net/npm/photoswipe@5/dist/photoswipe.css";
      const photoswipeLightboxSrc = "https://cdn.jsdelivr.net/npm/photoswipe@5/dist/photoswipe-lightbox.esm.min.js";
      const photoswipeModuleSrc = "https://cdn.jsdelivr.net/npm/photoswipe@5/dist/photoswipe.esm.min.js";
      const ensureStylesheet = (href) => {
        if (document.querySelector(`link[rel="stylesheet"][href="${href}"]`)) return;
        const link = document.createElement("link");
        link.rel = "stylesheet";
        link.href = href;
        document.head.appendChild(link);
      };
      const getImageDimensions = (src, imgEl) => new Promise((resolve) => {
        const w = imgEl && imgEl.naturalWidth || 0;
        const h = imgEl && imgEl.naturalHeight || 0;
        if (w > 0 && h > 0) {
          resolve({ width: w, height: h });
          return;
        }
        const probe = new Image();
        probe.onload = () => {
          resolve({
            width: probe.naturalWidth || 1600,
            height: probe.naturalHeight || 900
          });
        };
        probe.onerror = () => resolve({ width: 1600, height: 900 });
        probe.src = src;
      });
      let initPromise = null;
      const init = async () => {
        if (initPromise) return initPromise;
        initPromise = (async () => {
          try {
            ensureStylesheet(photoswipeCss);
            const { default: PhotoSwipeLightbox } = await import(photoswipeLightboxSrc);
            const pswpModule = () => import(photoswipeModuleSrc);
            const lightbox = new PhotoSwipeLightbox({
              gallery: "main",
              children: "a[data-pswp-width]",
              wheelToZoom: true,
              pswpModule
            });
            lightbox.init();
            const manualLb = new PhotoSwipeLightbox({ wheelToZoom: true, pswpModule });
            manualLb.init();
            const lightboxAnchors = Array.from(container.querySelectorAll("a.lightbox-image:not([data-pswp-width])")).map((a) => ({ a, img: a.querySelector("img") })).filter((x) => x.img);
            lightboxAnchors.forEach(({ a, img }) => {
              a.style.cursor = "zoom-in";
              a.addEventListener("click", async (e) => {
                e.preventDefault();
                const src = a.getAttribute("href");
                const dims = await getImageDimensions(src, img);
                manualLb.loadAndOpen(0, [{ src, width: dims.width, height: dims.height, alt: img.alt || "" }]);
              });
            });
            const orphanImgs = Array.from(container.querySelectorAll("img:not(a img)"));
            orphanImgs.forEach((img) => {
              img.style.cursor = "zoom-in";
              img.addEventListener("click", async () => {
                const src = img.currentSrc || img.src;
                const dims = await getImageDimensions(src, img);
                manualLb.loadAndOpen(0, [{ src, width: dims.width, height: dims.height, alt: img.alt || "" }]);
              });
            });
          } catch (e) {
          }
        })();
        return initPromise;
      };
      if (typeof window.requestIdleCallback === "function") {
        window.requestIdleCallback(() => {
          void init();
        }, { timeout: 2e3 });
      } else {
        setTimeout(() => {
          void init();
        }, 300);
      }
    })();
    document.addEventListener("click", async (ev) => {
      const btn = ev.target.closest("[data-copy-code]");
      if (!btn) return;
      const wrapper = btn.closest(".codeblock");
      if (!wrapper) return;
      const pre = wrapper.querySelector(".highlight pre");
      if (!pre) return;
      try {
        const text = pre.textContent || "";
        await navigator.clipboard.writeText(text);
        const copiedText = btn.getAttribute("data-copied-text") || "COPIED";
        const copiedTitle = btn.getAttribute("data-copied-title") || copiedText;
        if (btn.hasAttribute("data-icon-button")) {
          const originalTitle = btn.getAttribute("data-original-title") || btn.title || "";
          if (!btn.hasAttribute("data-original-title")) btn.setAttribute("data-original-title", originalTitle);
          btn.classList.add("is-copied");
          btn.title = copiedTitle;
          setTimeout(() => {
            btn.classList.remove("is-copied");
            btn.title = btn.getAttribute("data-original-title") || originalTitle;
          }, 1200);
        } else {
          const original = btn.textContent;
          btn.textContent = copiedText;
          setTimeout(() => {
            btn.textContent = original;
          }, 1200);
        }
      } catch (e) {
      }
    });
    document.addEventListener("click", (ev) => {
      const btn = ev.target.closest("[data-wrap-toggle]");
      if (!btn) return;
      const wrapper = btn.closest(".codeblock");
      if (!wrapper) return;
      const isWrapped = wrapper.classList.toggle("wrapped");
      btn.setAttribute("aria-pressed", isWrapped ? "true" : "false");
      const wrapText = btn.getAttribute("data-wrap-text") || "WRAP";
      const nowrapText = btn.getAttribute("data-nowrap-text") || "NOWRAP";
      const wrapTitle = btn.getAttribute("data-wrap-title") || wrapText;
      const nowrapTitle = btn.getAttribute("data-nowrap-title") || nowrapText;
      if (btn.hasAttribute("data-icon-button")) {
        btn.classList.toggle("is-active", isWrapped);
        btn.title = isWrapped ? nowrapTitle : wrapTitle;
      } else {
        btn.textContent = isWrapped ? nowrapText : wrapText;
      }
    });
    const themeBtn = document.querySelector("[data-theme-toggle]");
    if (themeBtn) {
      const root = document.documentElement;
      const applyTheme = (theme) => {
        root.setAttribute("data-theme", theme);
        localStorage.setItem("theme", theme);
      };
      const current = root.getAttribute("data-theme") || (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");
      applyTheme(current);
      themeBtn.addEventListener("click", () => {
        const next = root.getAttribute("data-theme") === "dark" ? "light" : "dark";
        applyTheme(next);
        try {
          window.dispatchEvent(new Event("themechange"));
        } catch (_) {
        }
      });
    }
    (() => {
      const tagCloud = document.getElementById("tags");
      const postList = document.querySelector("ul.blog-posts[data-tag-filter]");
      const filtersContainer = document.getElementById("tag-filters");
      if (!tagCloud || !postList) return;
      const searchInput2 = document.getElementById("blog-search");
      const indexUrl = searchInput2 && searchInput2.getAttribute("data-index-url") || "/index.json";
      const noResultsText = searchInput2 && searchInput2.getAttribute("data-no-results") || "No results";
      const fuseSrc = "https://cdn.jsdelivr.net/npm/fuse.js@7.0.0";
      let fuseInstance = null;
      let indexData = null;
      const base = tagCloud.getAttribute("data-base") || window.location.pathname;
      const filteringFor = tagCloud.getAttribute("data-filtering-for") || "Filtering for:";
      const removeAllLabel = tagCloud.getAttribute("data-remove-all") || "Remove all filters";
      const removeTagTitle = tagCloud.getAttribute("data-remove-tag") || "Remove tag";
      const escapeHtml = (value) => String(value).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
      const decodeTags = () => {
        const b64 = tagCloud.getAttribute("data-tags") || "";
        if (!b64) return [];
        try {
          const bytes = Uint8Array.from(atob(b64), (c) => c.charCodeAt(0));
          const json = new TextDecoder("utf-8").decode(bytes);
          const arr = JSON.parse(json);
          return Array.isArray(arr) ? arr : [];
        } catch (_) {
          return [];
        }
      };
      const normalizeTag = (t) => String(t || "").trim().toLowerCase().replace(/\s+/g, "-");
      const allTags = decodeTags().map(normalizeTag).filter(Boolean);
      const params = new URLSearchParams(window.location.search);
      const q = (params.get("q") || "").trim();
      const activeTags = q.split(",").map(normalizeTag).filter(Boolean);
      const items = Array.from(postList.querySelectorAll("li"));
      const parseItemTags = (li) => {
        const el = li.querySelector("[data-tags]");
        const raw = el ? el.textContent || "" : "";
        return raw.split("|").map(normalizeTag).filter(Boolean);
      };
      const hasAll = (tags, required) => required.every((t) => tags.includes(t));
      const ensureFuse = async () => {
        if (fuseInstance) return fuseInstance;
        if (!searchInput2) return null;
        if (!indexData) {
          try {
            const res = await fetch(indexUrl);
            if (!res.ok) return null;
            indexData = await res.json();
          } catch (_) {
            return null;
          }
        }
        if (!Array.isArray(indexData)) return null;
        if (!window.Fuse) {
          await new Promise((resolve, reject) => {
            const existing = document.querySelector(`script[src="${fuseSrc}"]`);
            if (existing) return resolve();
            const s = document.createElement("script");
            s.src = fuseSrc;
            s.defer = true;
            s.onload = () => resolve();
            s.onerror = () => reject(new Error("Failed to load Fuse"));
            document.head.appendChild(s);
          }).catch(() => null);
        }
        if (!window.Fuse) return null;
        const options = {
          includeScore: true,
          threshold: 0.3,
          ignoreLocation: true,
          minMatchCharLength: 2,
          keys: [
            { name: "title", weight: 2 },
            { name: "summary", weight: 1 },
            { name: "tags", weight: 0.75 },
            { name: "content", weight: 0.25 }
          ]
        };
        fuseInstance = new window.Fuse(indexData, options);
        return fuseInstance;
      };
      const normalizeHref = (href) => {
        try {
          const u = new URL(href, window.location.origin);
          return u.pathname;
        } catch (_) {
          return href;
        }
      };
      const applyVisibility = async () => {
        const searchQuery = searchInput2 ? String(searchInput2.value || "").trim() : "";
        let searchMatches = null;
        if (searchQuery) {
          const fuse = await ensureFuse();
          if (fuse) {
            const results = fuse.search(searchQuery).slice(0, 100);
            searchMatches = new Set(results.map((r) => normalizeHref(r.item && r.item.permalink || "")));
          } else {
            searchMatches = /* @__PURE__ */ new Set();
            if (indexData && Array.isArray(indexData)) {
              indexData.forEach((item) => {
                const title = String(item && item.title ? item.title : "").toLowerCase();
                if (title.includes(searchQuery.toLowerCase())) {
                  searchMatches.add(normalizeHref(item.permalink || ""));
                }
              });
            }
          }
        }
        const visibleTags = [];
        let visibleCount = 0;
        items.forEach((li) => {
          const tags = parseItemTags(li);
          const passesTags = activeTags.length ? hasAll(tags, activeTags) : true;
          const a = li.querySelector("a[href]");
          const href = a ? normalizeHref(a.getAttribute("href") || "") : "";
          const passesSearch = !searchMatches || href && searchMatches.has(href);
          const show = passesTags && passesSearch;
          li.style.display = show ? "" : "none";
          if (show) {
            visibleCount += 1;
            visibleTags.push(tags);
          }
        });
        if (searchInput2) {
          let emptyP = document.getElementById("blog-search-empty");
          if (!emptyP) {
            emptyP = document.createElement("p");
            emptyP.id = "blog-search-empty";
            emptyP.innerHTML = `<small>${escapeHtml(noResultsText)}</small>`;
            postList.parentElement && postList.parentElement.insertBefore(emptyP, postList);
          }
          emptyP.style.display = searchQuery && visibleCount === 0 ? "" : "none";
        }
        return visibleTags;
      };
      const renderFilters = () => {
        if (!filtersContainer) return;
        if (activeTags.length) {
          const tags = activeTags.map((tag) => {
            const remaining = activeTags.filter((t) => t !== tag);
            const href = remaining.length ? `${base}?q=${encodeURIComponent(remaining.join(","))}` : base;
            return `<a class="active-tag" rel="nofollow" href="${href}" title="${escapeHtml(removeTagTitle)}">#${escapeHtml(tag)}<span class="active-tag-x">\xD7</span></a>`;
          }).join("");
          filtersContainer.innerHTML = `<div class="active-filters">${tags}<a class="clear-filters" rel="nofollow" href="${base}">${escapeHtml(removeAllLabel)}</a></div>`;
        } else {
          filtersContainer.innerHTML = "";
        }
      };
      const computeAvailableTagsForCloud = () => {
        const available = /* @__PURE__ */ new Set();
        items.forEach((li) => {
          const tags = parseItemTags(li);
          const passesTags = activeTags.length ? hasAll(tags, activeTags) : true;
          if (passesTags) tags.forEach((t) => available.add(t));
        });
        return available;
      };
      const renderTagCloud = () => {
        const availableTags = computeAvailableTagsForCloud();
        const tagsToShow = allTags.filter((t) => !activeTags.includes(t) && availableTags.has(t));
        tagCloud.innerHTML = "";
        const honey = document.createElement("a");
        honey.rel = "nofollow";
        honey.href = `${base}?q=pot-of-honey`;
        honey.textContent = "#potofhoney";
        honey.style.display = "none";
        tagCloud.appendChild(honey);
        tagCloud.appendChild(document.createTextNode(" "));
        tagsToShow.forEach((tag) => {
          const a = document.createElement("a");
          const next = activeTags.length ? `${activeTags.join(",")},${tag}` : tag;
          a.href = `${base}?q=${encodeURIComponent(next)}`;
          a.textContent = `#${tag}`;
          a.rel = "nofollow";
          tagCloud.appendChild(a);
          tagCloud.appendChild(document.createTextNode(" "));
        });
      };
      renderFilters();
      renderTagCloud();
      void applyVisibility();
      if (searchInput2) {
        searchInput2.addEventListener("focus", () => {
          void ensureFuse();
        }, { once: true });
        searchInput2.addEventListener("input", () => {
          void applyVisibility();
        });
      }
    })();
  });
})();
